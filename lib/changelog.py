#!/usr/bin/env python
"""Manipulation of upstream and debian change log files

The upstream change log files format handled is simpler than the one
often used such as those generated by the default Emacs changelog mode.

Sample ChangeLog format:
------------------------------------------------------------
Change log for project Yoo
==========================

 --
    * add a new functionnality

2002-02-01 -- 0.1.1
    * fix bug #435454
    * fix bug #434356
    
2002-01-01 -- 0.1
    * initial release
    
------------------------------------------------------------

There is 3 entries in this change log, one for each released version and one
for the next version (i.e. the current entry).
Each entry contains a set of messages corresponding to changes done in this
release.
All the non empty lines before the first entry are considered as the change
log title.
This module should be able to find the change log file by itself.


See the debian documentation for the debian change log format.
"""

import sys
import os
import time
from os.path import join, isfile, dirname, exists
from logilab.common.fileutils import ensure_fs_mode
from stat import S_IWRITE

BULLET = '*'
INDENT = '    '
CHANGEFILE = 'ChangeLog'

def find_ChangeLog(base_dir=None):
    """try to find a ChangeLog file from a base directory"""
    if base_dir is None:
        base_dir = os.getcwd()
    while base_dir:
        filepath = join(base_dir, CHANGEFILE)
        if isfile(filepath):
            return filepath
        new_dir = dirname(base_dir)
        if new_dir == base_dir:
            raise ChangeLogNotFound()
        base_dir = new_dir
    raise ChangeLogNotFound()

def find_debian_changelog(base_dir=None):
    """try to find a debian changelog file from a base directory"""
    if base_dir is None:
        base_dir = os.getcwd()
    while base_dir:
        filepath = join(base_dir, 'debian', 'changelog')
        if isfile(filepath):
            return filepath
        new_dir = dirname(base_dir)
        if new_dir == base_dir:
            raise ChangeLogNotFound()
        base_dir = new_dir
    raise ChangeLogNotFound()

def get_pkg_version(base_dir=None):
    """return the current package version
    """
    if base_dir is None:
        base_dir = os.getcwd()
    if exists(join(base_dir, 'version.txt')):
        return open(join(base_dir, 'version.txt')).read().strip()
    sys.path.insert(0, base_dir)
    mod = __import__('__pkginfo__')
    sys.path.pop(0)
    try:
        sys.modules['__pkginfo__'] # FIXME what is this for ?
    except KeyError:
        pass
    return mod.version


class NoEntry(Exception):
    """raised when we are unable to find an entry"""

class EntryNotFound(Exception):
    """raised when we are unable to find a given entry"""

class NoOpenEntry(EntryNotFound):
    """raised when we are unable to find an opened entry"""

class ChangeLogNotFound(Exception):
    """raised when we are unable to locate the change log"""

# upstream change log #########################################################

class ChangeLogEntry:
    """a change log entry, ie a set of messages associated to a version and
    its release date
    """
    def __init__(self, date='', version='', **kwargs):
        self.__dict__.update(kwargs)
        self.version = version
        self.date = date
        self.messages = []
        
    def add_message(self, msg):
        """add a new message"""
        self.messages.append([msg])

    def complete_latest_message(self, msg_suite):
        """complete the latest added message
        """
        if not self.messages:
            print >> sys.stderr, 'Ignoring %r (unexpected format)' % msg_suite
        self.messages[-1].append(msg_suite)

    def write(self, stream=sys.stdout):
        """write the entry to file """
        stream.write('%s  --  %s\n' % (self.date, self.version))
        for msg in self.messages:
            stream.write('%s%s %s\n' % (INDENT, BULLET, msg[0]))
            stream.write(''.join(msg[1:]))
            #for more in msg[1:]:
            #    stream.write('%s  %s\n' % (INDENT, more))
            #stream.write('\n')

def numversion(version_string):
    """return the version as a tuple of integer"""
    return [int(part) for part in version_string.split('.')]

class ChangeLog:
    """object representation of a whole ChangeLog file"""
    
    entry_class = ChangeLogEntry
    
    def __init__(self, changelog_file, title=''):
        self.file = changelog_file
        self.title = title
        self.entries = []
        self.load()

    def __repr__(self):
        return '<ChangeLog %s at %s (%s entries)>' % (self.file, id(self),
                                                      len(self.entries))
    
    def add_entry(self, entry):
        """add a new entry to the change log"""
        self.entries.append(entry)

    def get_entry(self, version='', create=None):
        """ return a given changelog entry
        if version is omited, return the current entry 
        """
        if not self.entries:
            if version or not create:
                raise NoEntry()
            self.entries.append(self.entry_class())

        if not version:
            if self.entries[0].version and create is not None:
                self.entries.insert(0, self.entry_class())
            return self.entries[0]
        
        for entry in self.entries:
            if entry.version == version:
                return entry
            
        raise EntryNotFound()

    def get_latest_revision(self):
        """return the latest revision found or 0.0.0"""
        for entry in self.entries:
            if entry.version:
                return entry.version
        return '0.0.0'
    
    def add(self, msg, create=None):
        """add a new message to the latest opened entry"""
        entry = self.get_entry(create=create)
        entry.add_message(msg)

    def formatted_date(self):        
        return time.strftime('%Y-%m-%d', time.localtime(time.time()))
    
    def close(self, base_dir, create=None):
        """close the opened change log entry"""
        version = get_pkg_version(base_dir)
        entry = self.get_entry(create=create)
        today = self.formatted_date()
        if len(self.entries) > 1:
            assert numversion(self.entries[1].version) < numversion(version), \
                   '%s >= %s !' % (self.entries[1].version, version)
            assert self.entries[1].date <= today, '%s > %s !' % (
                self.entries[1].date, today)
        entry.date = today
        entry.version = version

    def extract(self, version='', stream=sys.stdout):
        """extract messages for a given entry"""
        self.get_entry(version).write(stream)

    def update(self, create=None):
        """update the change log by extracting infos from cvs

        FIXME: use vcs_agent.log_info to extract log info
        """
        entry = self.get_entry(create=create)
        tag = 'version-%s' % (self.get_latest_revision().replace('.', '_'))
        stream = os.popen('cvslog -- -- -r%s::' % tag)
        for line in stream.readlines():
            entry.add_message(line)
    
    def load(self):
        """ read a logilab's ChangeLog from file """
        try:
            stream = open(self.file)
        except IOError:
            return
        last = None
        for line in stream.readlines():
            #line = line.strip()
            #if not line :
            #    continue
            sline = line.strip()
            words = sline.split()
            if len(words) == 1 and words[0] == '--':
                last = self.entry_class()
                self.add_entry(last)
            elif len(words) == 3 and words[1] == '--':
                last = self.entry_class(words[0], words[2])
                self.add_entry(last)
            elif last is None:
                if not sline:
                    continue
                self.title = '%s%s' % (self.title, line)
            elif sline and sline[0] == BULLET:
                last.add_message(sline[1:].strip())
            elif last.messages:
                last.complete_latest_message(line)
        stream.close()
        
    def save(self):
        """write back change log"""
        ensure_fs_mode(self.file, S_IWRITE)
        self.write(open(self.file, 'w'))
        
    def format_title(self):
        return '%s\n\n' % self.title.strip()
    
    def write(self, stream=sys.stdout):
        """ write a changelog to file """
        stream.write(self.format_title())
        for entry in self.entries:
            entry.write(stream)

# debian change log ###########################################################

class DebianChangeLogEntry(ChangeLogEntry):
    def write(self, stream=sys.stdout):
        """write the entry to file """
        write = stream.write
        write('%s (%s) %s; urgency=%s\n\n' % (self.package, self.version,
                                              self.distrib, self.urgency))
        for msg in self.messages:
            write('  * %s' % ''.join(msg))
            #write(''.join(msg[1:]))
        write(' -- %s  %s\n\n' % (self.author, self.date))


class DebianChangeLog(ChangeLog):
    """object representation of a whole debian/changelog file"""
    
    entry_class = DebianChangeLogEntry

    def formatted_date(self):
        return time.strftime('%a, %d %b %Y %T %z', time.localtime(time.time()))
    
    def close(self, base_dir, create=None):
        
        """close the opened change log entry"""
        version = get_pkg_version(base_dir)
        entry = self.get_entry(create=create)
        today = self.formatted_date()
        if len(self.entries) > 1:
            upstream_version, debian_version = chlg.entries[1].version.split()
            assert upstream_version <= version
            assert chlg.entries[1].date < today
            if version == upstream_version:
                debian_version = str(int(debian_version) + 1)
            else:
                debian_version = '1'
            version = '%s-%s' % (version, debian_version)
        else:
            version = '%s-1' % version
        entry.date = today
        entry.version = version

    def format_title(self):
        return ''
            
    def load(self):
        """ read a debian/changelog from file """
        try:
            stream = open(self.file)
        except IOError:
            return
        last = None
        for line in stream.readlines():
            sline = line.strip()
            #if not line :
            #    continue
            if sline.startswith('-- '):
                try:
                    author, date = sline[3:].split('>')
                    author = author.strip() + '>'
                    date = date.strip()
                except TypeError:
                    author, date = '', ''
                last.date = date
                last.author = author
                last = None
            elif 'urgency' in sline:
                pkg, version, distrib, urgency = sline.split()
                version = version[1:-1]
                urgency = urgency[8:]
                distrib = distrib[:-1]
                last = self.entry_class(version=version, package=pkg,
                                        urgency=urgency, distrib=distrib)
                self.add_entry(last)
            elif last:
                if sline.startswith('* '):
                    last.add_message(line.lstrip()[1:].lstrip())
                elif last.messages:
                    last.complete_latest_message(line)
        stream.close()

